<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SPB Brewhaus</title>
<style>
  :root{ --title:1.4rem; --section:1.2rem; --content:1.06rem; }
  html{ font-size:16px; }
  body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:20px; line-height:1.45; color:#111; }
  h2,h3{ color:#0b57d0; margin:.25rem 0 .5rem; }
  h2{ font-size:var(--title); }
  h3{ font-size:var(--section); }
  .muted{ color:#666; font-style:italic; }
  .section{ margin:1rem 0; font-size:var(--content); }
  details{ margin:.75rem 0; }
  details summary{ cursor:pointer; }
  ul,ol{ margin:.25rem 0 .75rem 1.25rem; }
  .table-wrap{ max-width:880px; margin:.25rem auto 1rem; padding:0 .25rem; }
  table{ width:100%; border-collapse:collapse; font-size:var(--content); }
  th,td{ border:1px solid #ddd; padding:6px 8px; text-align:left; vertical-align:top; }
  th{ background:#f5f3ee; font-weight:600; }
  @media (max-width:420px){ :root{ --title:1.35rem; --section:1.16rem; --content:1.02rem; } }
</style>
</head>
<body>

<h2>S.P.B. Brewhaus</h2>
<div id="last-updated" class="muted" style="margin:.25rem 0 .75rem" aria-live="polite"></div>
<p class="muted">Values in table represent backups</p>

<!-- Inventory Tables -->
<div id="upstairs-table"   class="section">Loading‚Ä¶</div>
<div id="downstairs-table" class="section">Loading‚Ä¶</div>
<div id="ondeck-table"     class="section">Loading‚Ä¶</div>

<!-- Content (lists) from individual .txt files -->
<div id="content-sections" class="section"></div>

<!-- Maintenance -->
<details class="section" open>
  <summary>‚öôÔ∏è Maintenance & Logs</summary>
  <div id="maintenance" style="margin-top:.5rem;">Loading‚Ä¶</div>
  <p style="margin:.5rem 0 0;">
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSeMIzh7LHuZMFyK7xNuJIg30oSsXO_VFRJEswS-piHc_RX37A/viewform" target="_blank">üîê Staff link to submit maintenance form</a>
  </p>
  <p class="muted" style="margin:.25rem 0 0;">Note: updates appear automatically on this page after saving the sheet.</p>
</details>

<p class="section">
  <a href="https://docs.google.com/spreadsheets/d/13-oglKrmnpkJok_xEO7brLNmnetRz3XIkrc2gSXf4X0/edit?usp=sharing" target="_blank">üîê Staff Login to Update Inventory</a>
</p>

<script>
/* ----------------- Helpers ----------------- */
const normalize = s => (s||"").toLowerCase().replace(/\s+/g," ").trim();

function parseCSV(text){
  const out=[]; let row=[], field="", q=false;
  for (let i=0;i<text.length;i++){
    const c=text[i], n=text[i+1];
    if(q){ if(c==='"'&&n==='"'){field+='"';i++;} else if(c==='"'){q=false;} else field+=c; }
    else{
      if(c==='"') q=true;
      else if(c===','){ row.push(field); field=""; }
      else if(c==='\n'||c==='\r'){ if(c==='\r'&&n==='\n') i++; row.push(field); field=""; if(row.some(v=>(v||"").trim()!=="")) out.push(row); row=[]; }
      else field+=c;
    }
  }
  if(field.length||row.length){ row.push(field); out.push(row); }
  return out;
}

async function fetchLines(url){
  const r = await fetch(url + '?cb=' + Date.now(), { cache:'no-store' });
  if(!r.ok) throw new Error(url + ' HTTP ' + r.status);
  const text = await r.text();
  return text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
}

function listHTML(lines){ return lines.length ? `<ul>${lines.map(li=>`<li>${li}</li>`).join("")}</ul>` : `<div class="muted">No items.</div>`; }

/* ----------------- Inventory (CSV) + Last Updated ----------------- */
async function renderInventory(){
  const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTn3XrnFcps7_xm4HBCDfHCss0DB0Wwd5DRlXGxvE4hk9Nc_Hw8-6HuB6LS7p09BlOP44FhL_ByR1kQ/pub?output=csv";
  const upEl   = document.getElementById("upstairs-table");
  const downEl = document.getElementById("downstairs-table");
  const deckEl = document.getElementById("ondeck-table");

  function getStockIcon(status){
    if(!status) return "";
    const s = status.toLowerCase();
    if (s.includes("good")) return " ‚úÖ";
    if (s.includes("low"))  return " üü°";
    if (s.includes("out"))  return " ‚ùå";
    return "";
  }

  function buildTable(rows){
    let html = `<div class="table-wrap"><table><thead><tr>
      <th>Tap</th><th>Beer + Status</th><th>1/2 bbl</th><th>1/6 bbl</th><th>Cases of Cans</th>
    </tr></thead><tbody>`;
    for(const r of rows){
      const icon  = getStockIcon(r.stock);
      const notes = r.notes ? `<div class="muted">${r.notes}</div>` : "";
      html += `<tr>
        <td>${r.tap||""}</td>
        <td><strong>${r.beer||""}${icon}</strong>${r.status? " ‚Äî "+r.status:""}${notes}</td>
        <td>${r.half||""}</td><td>${r.sixth||""}</td><td>${r.cans||""}</td>
      </tr>`;
    }
    html += `</tbody></table></div>`;
    return html;
  }

  try{
    const res  = await fetch(CSV_URL, { cache:"no-cache", mode:"cors" });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const rows = parseCSV(await res.text());
    if(!rows.length) throw new Error("Empty CSV");

    const header = rows[0].map(h => normalize(h));
    const gi = name => header.indexOf(name);
    const idx = {
      location: gi("location"),
      tap: gi("tap"),
      beer: gi("beer"),
      status: gi("status"),
      half: gi("1/2 bbl"),
      sixth: gi("1/6 bbl"),
      cans: gi("cases of cans"),
      stock: gi("stock status"),
      notes: gi("notes"),
      dateUpdated: (["date updated","updated","last updated","last_update","lastupdated"]
                    .map(n=>header.indexOf(n)).find(i=>i>=0))
    };

    const data = rows.slice(1).map(r => ({
      location:r[idx.location]||"", tap:r[idx.tap]||"", beer:r[idx.beer]||"",
      status:r[idx.status]||"", half:r[idx.half]||"", sixth:r[idx.sixth]||"",
      cans:r[idx.cans]||"", stock:r[idx.stock]||"", notes:r[idx.notes]||"",
      du: idx.dateUpdated!=null ? (r[idx.dateUpdated]||"") : ""
    }));

    // Last Updated = newest valid date in the dateUpdated column
    (function(){
      function parseDateLoose(s){
        if(!s) return NaN;
        let d=new Date(s); if(!isNaN(d)) return d;
        const m=String(s).trim().match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
        if(m){ let [_,mm,dd,yyyy]=m; if(yyyy.length===2) yyyy=(+yyyy<70?'20':'19')+yyyy;
          d=new Date(+yyyy, +mm-1, +dd); if(!isNaN(d)) return d; }
        return NaN;
      }
      const latest = data.reduce((acc, row)=>{
        const d=parseDateLoose(row.du);
        return (d instanceof Date && !isNaN(d) && (!acc || d>acc)) ? d : acc;
      }, null);
      const el = document.getElementById("last-updated");
      if(el) el.textContent = latest ? `Updated ${latest.toLocaleString('en-US',{dateStyle:'medium',timeStyle:'short'})}` : "";
    })();

    const isUp   = s => /up|upstairs/i.test(s);
    const isDown = s => /down|downstairs/i.test(s);
    const isDeck = s => /deck/i.test(s);

    const upstairs   = data.filter(x => isUp(x.location));
    const downstairs = data.filter(x => isDown(x.location));
    const ondeck     = data.filter(x => isDeck(x.location));

    upEl.innerHTML   = `<h3>Upstairs ‚Äî On Tap</h3>`   + (upstairs.length   ? buildTable(upstairs)   : `<div class="muted">No rows found.</div>`);
    downEl.innerHTML = `<h3>Downstairs ‚Äî On Tap</h3>` + (downstairs.length ? buildTable(downstairs) : `<div class="muted">No rows found.</div>`);
    deckEl.innerHTML = `<h3>On Deck</h3>`             + (ondeck.length     ? buildTable(ondeck)     : `<div class="muted">No rows found.</div>`);
  }catch(e){
    console.error(e);
    upEl.textContent   = "Failed to load inventory.";
    downEl.textContent = "Failed to load inventory.";
    deckEl.textContent = "Failed to load inventory.";
  }
}

/* ----------------- Lists from .txt files ----------------- */
async function renderTxtLists(){
  const mount = document.getElementById('content-sections');
  if(!mount) return;

  // Simple sections: one .txt per section (one item per line)
  const simpleSections = [
    { title:"ü™ñ In the Tanks", file:"/data/tanks.txt" },
    { title:"üõ† To Brew",      file:"/data/tobrew.txt" },
    { title:"‚öóÔ∏è Chemicals",    file:"/data/chemicals.txt" },
    { title:"Gas levels",      file:"/data/gas.txt" }
  ];

  // Details sections: either a single .txt or grouped .txts
  const detailBlocks = [
    { summary:"üîÆ Future Maintenance", open:false, file:"/data/future_maintenance.txt" },
    { summary:"üìÑ Orders",             open:false, file:"/data/orders.txt" },
    { summary:"üßª Labels Needed",      open:false, groups:[
        { heading:"Upcoming Brews", file:"/data/labels_upcoming.txt" },
        { heading:"Inventory",      file:"/data/labels_inventory.txt" }
      ]
    },
    { summary:"üì¶ Ingredients", open:false, groups:[
        { heading:"Needed", file:"/data/ingredients_needed.txt" }
      ],
      // Special nested section built from a single text file with automated sorting
      hopsFile:"/data/hops_on_hand.txt", hopsSummary:"üåø Hops On Hand"
    }
  ];

  function sectionHTML(title, lines){ return `<div class="section"><h3>${title}</h3>${listHTML(lines)}</div>`; }

  function groupsHTML(groups){
    return groups.map(g => `<p><strong>${g.heading}</strong></p>${listHTML(g.items||[])}`).join("");
  }

  function detailsHTML({summary, open, lines, groups, subcontentHTML}){
    let inner = "";
    if (lines)  inner += listHTML(lines);
    if (groups) inner += groupsHTML(groups);
    if (subcontentHTML) inner += subcontentHTML;
    return `<details class="section"${open?' open':''}><summary>${summary}</summary><div>${inner}</div></details>`;
  }

  // Hops auto-sorter: read lines, sort A‚ÜíZ by hop name, bucket into A‚ÄìC / D‚ÄìN / S‚ÄìZ
  async function buildHopsHTML(hopsFile, summaryText){
    try{
      const lines = await fetchLines(hopsFile); // e.g., "Amarillo ‚Äî (5 lbs)"
      const parseName = s => {
        const m = s.split('‚Äî')[0].split('-')[0]; // take text before en-dash or hyphen
        return (m||s).trim();
      };
      const items = lines.map(line => ({ name: parseName(line), full: line }))
                         .sort((a,b)=> a.name.localeCompare(b.name,'en',{sensitivity:'base'}));

      const buckets = { "A‚ÄìC":[], "D‚ÄìN":[], "S‚ÄìZ":[] };
      for(const it of items){
        const ch = (it.name[0]||'').toUpperCase();
        if (ch >= 'A' && ch <= 'C') buckets["A‚ÄìC"].push(it.full);
        else if (ch >= 'D' && ch <= 'N') buckets["D‚ÄìN"].push(it.full);
        else buckets["S‚ÄìZ"].push(it.full);
      }

      const sub = `
        <details><summary>${summaryText}</summary>
          <div>
            <p><strong>A‚ÄìC</strong></p>${listHTML(buckets["A‚ÄìC"])}
            <p><strong>D‚ÄìN</strong></p>${listHTML(buckets["D‚ÄìN"])}
            <p><strong>S‚ÄìZ</strong></p>${listHTML(buckets["S‚ÄìZ"])}
          </div>
        </details>
      `;
      return sub;
    }catch(e){
      console.error('hops', e);
      return `<details><summary>${summaryText}</summary><div class="muted">Couldn't load hops list.</div></details>`;
    }
  }

  try{
    let html = "";

    // Render simple sections
    for (const s of simpleSections){
      const lines = await fetchLines(s.file).catch(()=>[]);
      html += sectionHTML(s.title, lines);
    }

    // Render details blocks
    for (const d of detailBlocks){
      let lines = null, groups = null, subcontentHTML = "";

      if (d.file) lines = await fetchLines(d.file).catch(()=>[]);
      if (d.groups){
        groups = [];
        for (const g of d.groups){
          const glines = await fetchLines(g.file).catch(()=>[]);
          groups.push({ heading:g.heading, items:glines });
        }
      }
      if (d.hopsFile){
        subcontentHTML = await buildHopsHTML(d.hopsFile, d.hopsSummary || "Hops On Hand");
      }

      html += detailsHTML({ summary:d.summary, open:d.open, lines, groups, subcontentHTML });
    }

    mount.innerHTML = html;
  }catch(e){
    console.error(e);
    mount.textContent = "Couldn't load sections.";
  }
}

/* ----------------- Maintenance (CSV) ----------------- */
async function renderMaintenance(){
  const MAINT_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTn3XrnFcps7_xm4HBCDfHCss0DB0Wwd5DRlXGxvE4hk9Nc_Hw8-6HuB6LS7p09BlOP44FhL_ByR1kQ/pub?gid=2038532004&single=true&output=csv";
  const el = document.getElementById("maintenance");
  try{
    const res  = await fetch(MAINT_CSV_URL, { cache:"no-cache", mode:"cors" });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const rows = parseCSV(await res.text());
    if(!rows.length) throw new Error("Empty CSV");

    const header = rows[0].map(h => (h||"").trim().toLowerCase());
    const iSys   = header.indexOf("system");
    const iDate  = header.indexOf("date");
    const iEvent = header.indexOf("event");
    if(iSys<0 || iDate<0 || iEvent<0){
      el.innerHTML = "<em>Expected headers: System, Date, Event.</em>";
      return;
    }

    const data = rows.slice(1).filter(r => r.some(v => (v||"").trim()!==""));
    const groups = {};
    for(const r of data){
      const key=(r[iSys]||"Other").trim();
      (groups[key] ||= []).push(r);
    }
    for(const k of Object.keys(groups)){
      groups[k].sort((a,b)=>{
        const da=new Date(a[iDate]), db=new Date(b[iDate]);
        return (isNaN(db)-isNaN(da)) || (db-da);
      });
    }

    let html = "";
    for(const [sys, list] of Object.entries(groups)){
      html += `<h3>${sys} Log</h3><table><thead><tr><th>Date</th><th>Event</th></tr></thead><tbody>`;
      for(const r of list){ html += `<tr><td>${r[iDate]||""}</td><td>${r[iEvent]||""}</td></tr>`; }
      html += `</tbody></table>`;
    }
    el.innerHTML = html || "<em>No maintenance rows yet.</em>";
  }catch(e){
    console.error(e);
    el.textContent = "Failed to load maintenance log.";
  }
}

/* ----------------- Boot ----------------- */
document.addEventListener("DOMContentLoaded", () => {
  renderInventory();
  renderTxtLists();
  renderMaintenance();
});
</script>
</body>
</html>
